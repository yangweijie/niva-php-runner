<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>ThinkPHP with Niva iframe</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #main-iframe { width: 100vw; height: 100vh; border: none; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; }
  </style>
</head>
<body>
<div id="loading">正在检测服务并启动 PHP 服务器，请稍候...</div>
<iframe id="main-iframe" src="about:blank" style="display:none;"></iframe>
<script>
  // 应用启动时
  let processPid;
  let osInfo;
  let killed = false;
  // 启用窗口关闭请求拦截
  Niva.api.window.blockCloseRequested(true);
  Niva.addEventListener("window.closeRequested", (eventName, payload) => {
    console.log('窗口即将关闭，正在清理进程...');
    if (processPid) {
      try {
        // 根据操作系统选择合适的命令杀死进程
        if ( osInfo.os === "Windows") {
          Niva.api.process.exec('TASKKILL', ['/PID', processPid.toString(), '/F', '/T'])
                  .then(() => {
                    killed = true;
                  }).catch((e) => {
            Niva.api.window.close();
          });
        } else {
          Niva.api.process.exec('kill', ['-9', processPid.toString()]);
        }
        killed = true;
      } catch (error) {
        console.error('终止进程时出错:', error);
      }
      if (!killed) {
        console.log('终止进程时出错，正在强制关闭...');
        Niva.api.process.kill(processPid);
        // 完成清理后关闭窗口
        Niva.api.window.close();
      }else{
        // Niva.api.window.close();
      }

    }
  });
  // 端口检测和自动启动 PHP 服务器（需 Niva 环境支持）
  const PHP_PORT = 3000;
  async function checkPort(port) {
    return httpGetWithTimeout(`http://localhost:${port}`).then(()=>{
      document.getElementById('loading').innerHTML = 'php服务已启动 pid:'+processPid;
      return true;
    }).catch((e)=>{
      console.log(e.message);
      return false;
    });
  }
  function httpGetWithTimeout(url, timeout = 3000) {
    return Promise.race([
      Niva.api.http.get(url),
      new Promise((_, reject) => setTimeout(() => reject(new Error('请求超时')), timeout))
    ]);
  }
  async function startPhpServer() {
    let cwd = '';
    if (window.Niva && Niva.api && Niva.api.process) {
      try {
        Niva.api.process.currentDir().then(currentDir => {
          cwd = currentDir+`\\php\\tp`;
          const PHP_CMD =`${cwd}\\bin\\php.exe`;
          const PHP_ARGS = ["-S", `localhost:${PHP_PORT}`, "-t", `${cwd}\\public`];
          Niva.api.process.exec(PHP_CMD, PHP_ARGS, {detached:true, cwd:cwd}).then(pid => {
            console.log('PHP 服务器已启动，PID:', pid);
            document.getElementById('loading').innerText = 'PHP 服务器已启动，PID: ' + pid;
            processPid = pid;
            console.log(processPid);
          });
        }).catch(err => {
          document.getElementById('currentDir').textContent = "获取失败: " + err;
        });
      } catch (e) {
        document.getElementById('loading').innerText = 'PHP 服务器启动失败：' + e;
      }
    } else {
      document.getElementById('loading').innerText = 'Niva 环境未检测到，无法自动启动 PHP 服务器。';
    }
  }
  async function main() {
    osInfo = await Niva.api.os.info();
    console.log(osInfo);
    let ready = await checkPort(PHP_PORT);
    if (!ready) {
      await startPhpServer();
      // 启动后等待端口可用
      for (let i = 0; i < 20; i++) {
        await new Promise(r => setTimeout(r, 500));
        if (await checkPort(PHP_PORT)) {
          ready = true;
          break;
        }
      }
    }
    if (ready) {
      // document.getElementById('loading').style.display = 'none';
      // const iframe = document.getElementById('main-iframe');
      // iframe.style.display = '';
      // iframe.src = PHP_ENTRY;
    } else {
      document.getElementById('loading').innerText = 'PHP 服务器未能启动，请手动检查。';
    }
  }
  main();
</script>
</body>
</html>.